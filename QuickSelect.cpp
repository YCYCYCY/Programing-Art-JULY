//输入n个整数，输出其中最小的k个
/*
一种在平均情况下，时间复杂度为O（N）的快速选择算法。如下述文字：

选取S中一个元素作为枢纽元v，将集合S-{v}分割成S1和S2，就像快速排序那样
如果k <= |S1|，那么第k个最小元素必然在S1中。在这种情况下，返回QuickSelect(S1, k)。
如果k = 1 + |S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它。
否则，这第k个最小元素就在S2中，即S2中的第（k - |S1| - 1）个最小元素，
我们递归调用并返回QuickSelect(S2, k - |S1| - 1)。
此算法的平均运行时间为O(n)。
*/
//QuickSelect 将第k小的元素放在 a[k-1]  
void QuickSelect( int a[], int k, int left, int right )
{
    int i, j;
    int pivot;

    if( left + cutoff <= right )
    {
        pivot = median3( a, left, right );
        //取三数中值作为枢纽元，可以很大程度上避免最坏情况
        i = left; j = right - 1;
        for( ; ; )
        {
            while( a[ ++i ] < pivot ){ }
            while( a[ --j ] > pivot ){ }
            if( i < j )
                swap( &a[ i ], &a[ j ] );
            else
                break;
        }
        //重置枢纽元
        swap( &a[ i ], &a[ right - 1 ] );  

        if( k <= i )
            QuickSelect( a, k, left, i - 1 );
        else if( k > i + 1 )
            QuickSelect( a, k-i-1, i + 1, right );
    }
    else  
        InsertSort( a + left, right - left + 1 );
}


//1、谷歌面试题：输入是两个整数数组，他们任意两个数的和又可以组成一个数组，
//求这个和中前k个数怎么做？
/*
http://blog.csdn.net/tnndye/article/details/12857577
假设两个整数数组为A和B，各有N个元素，任意两个数的和组成的数组C有N^2个元素。
可以把这些和看成N个有序数列：
A[1]+B[1] <= A[1]+B[2] <= A[1]+B[3] <=…

A[2]+B[1] <= A[2]+B[2] <= A[2]+B[3] <=…

…

A[N]+B[1] <= A[N]+B[2] <= A[N]+B[3] <=…
问题转变成，在这N个有序数列里，找到前k小的元素。
现在我们从N个序列中，每次取一个最小的元素，并删掉，
这样操作k次，就能得到想要的结果。
有个结论很显然，针对一个序列，取数的顺序一定是从左往右的（有序数列），
所以，我们一开始把所有序列的第一个元素都放进堆中，
每次删除最小值并放入新数列中，然后加入此数列的下一个元素，
如此操作K次，就得到我们想要的结果。
每次操作的时间复杂度为logN，一共操作k次，所以总时间复杂度为KlogN。
*/

//2、有两个序列A和B,A=(a1,a2,...,ak),B=(b1,b2,...,bk)，A和B都按升序排列。
//对于1<=i,j<=k，求k个最小的（ai+bj）。要求算法尽量高效。
/*
思路：比较A和B的两个元素，假设A元素Ai大，继续把B中的元素和Ai比较，
直到找到比Ai大的元素，或者统计个数达到了k。
*/

//3、给定一个数列a1,a2,a3,...,an和m个三元组表示的查询，
//对于每个查询(i，j，k)，输出ai，ai+1，...，aj的升序排列中第k个数。
/*
也是用类似快排的方法，削去两端。
遍历一次，若该枢纽元的位置i>k，则继续在0~i-1中寻找第k个元素。
遍历一次，若该枢纽元的位置i<k，则在i+1~n中寻找第k-i个元素
*/